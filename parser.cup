import java_cup.runtime.*;
import java.util.*;

/* Codigo para el manejo de errores */
parser code
{:

  public static LinkedList<String> msgErrores = new LinkedList<String>();

  public void report_error (String message, Object info) {
    /* if (s != null) {
      Symbol s2 = (Symbol) s;
      int fila = s2.right;
      int columna = s2.left;
      String currentToken = "Hola";
      System.out.println(message + " fila: " + fila + " columna: " + columna +
        " token inesperado " + currentToken);
    } */

    if (message.equalsIgnoreCase("Syntax error")) {
      message = "Error Sintactico";
    } else if (message.equalsIgnoreCase("Couldn't repair and continue parse")) {
      message = "Error";
    }
    if (info instanceof java_cup.runtime.Symbol) {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
      if (s.right >= 0) {
        System.out.println(s.right);
        message += ": en linea " + (s.right + 1);
        if (s.left >= 0) {
          message += ", columna " + (s.left + 1);
        }
        if(getScanner() instanceof Ada95) {
          message += "; no se esperaba '" + ((Ada95)getScanner()).getCurrentText()+"'";
        }
      }
    }
    msgErrores.add(message);
  }

  public void report_fatal_error (String message, Object info) {
    /* Symbol s2 = (Symbol) s;
    int fila = s2.right;
    int columna = s2.left;
    String currentToken = s2.value.toString();
    System.out.println(message + " fila: " + fila + " columna: " + columna +
      " token inesperado " + currentToken); */
    /* System.out.println("Error Sintactico"); */
    report_error(message, info);
  }

  // Metodo al se llama automaticamente ante algun error sintactico
  /* public void syntax_error (Symbol s) {
    int fila = s.right;
    int columna = s.left;
    String currentToken = s.value.toString();
    System.out.println("Error Sintactico " + " fila: " + fila + " columna: " + columna +
      " token inesperado " + currentToken);
    report_error("Error Sintactico", s);
  } */

  // Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
  /* public void unrecover_syntax_error(Symbol s) {
    String lexema = s.value.toString();
    int fila = s.right;
    int columna = s.left;
    System.out.println("!!! Error sintactico recuperado !!!!");
    System.out.println("Lexema " + lexema);
    System.out.println("Fila " + fila);
    System.out.println("Columna " + columna);
    report_fatal_error("Error fatal en la Sintaxis", s);
  } */

:}

/*Palabras reservadas*/
terminal ABORT, ELSE, NEW, RETURN, ABS, ELSIF, NOT;
terminal REVERSE, ABSTRACT, END, NULL, ACCEPT, ENTRY;
terminal SELECT, ACCESS, EXCEPTION, OF, SEPARATE;
terminal ALIASED, EXIT, OR, ALL, OTHERS, SUBPROCEDURE, AND;
terminal FOR, OUT, ARRAY, FUNCTION, AT, TAGGED, GENERIC;
terminal PACKAGEA, TASK, BEGIN, GOTO, PRAGMA, TERMINATE;
terminal BODY, PRIVATE, THEN, IF, PROCEDURE, TYPE, CASE;
terminal IN, PROTECTED, CONSTANT, UNTIL, IS, RAISE;

/* terminal use, with; */
terminal DECLARE, RANGE, DELAY, LIMITED, RECORD, WHEN;
terminal DELTA, LOOP, REM, WHILE, DIGITS, RENAMES;
terminal DO, MOD, REQUEUE, XOR;

/*terminal de comentarios*/
terminal COMMENT;

/*terminales de booleanos*/
terminal TRUE, FALSE;

/* terminal de valores */
terminal NUM;

/* Tipo de datos */
terminal DATATYPES, SUBTYPE;

/* Operadores */
terminal ARROW, DOUBD, DOUBAPS, ASSIGN, NOTEQ;
terminal LLB, RLB, BOX, QM, NS, AM, AP, LP, RP, OP;
terminal COMA, PUNTO, OPREL, DOS, PC;
terminal VERTICAL, LSQB, RSQB, LCB, RCB;

/* String */
terminal EXP;

/* Observacion con el guinb*/
terminal GUINB;

/* Funcion predefinidas */
terminal GET, PUT;

/* id para variables, procedimientos y funciones */
terminal ID;

/* Sección de no terminales */

non terminal A;

/* no terminales de procedimientos y funciones */
non terminal String F, G, H, I;

/* no terminales de terminales de ids*/
non terminal String X, X2;

/*no terminales de tipos de datos*/
non terminal String Z;

/* no terminales de valores */
non terminal String N, N1;

/* no terminales de declaración de tipos */
non terminal String C, D;

/* no terminales de las condicionales */
non terminal String L, L2, L4;

/* no terminales del cuerpo de expresiones */
non terminal String E;

/* no terminales de las operaciones */
non terminal String E2, E5, E6, E7;

/*no terminales de los retornos*/
non terminal String E3;

/* no terminales de iteraciones */
non terminal String M, M1;

/* no terminales de comparacion */
non terminal String L1, L3;

/* no terminales de grupo de comparaciones para mientras */
non terminal String L6;

/* no terminales de Funciones */
non terminal String E4;

/* no terminales de lista de paramtros */
non terminal String PA, PA2;

/* non terminales de obtener e imprimir valores */
non terminal String P, P1, P2;

start with A;

/* Procedimientos y Funciones */
A   ::=  F                              {: :}
    ;
F   ::=  PROCEDURE X:x IS G             {: /*procedure(G)*/ :}
    ;
G   ::=  C:c G                          {: :}
    |   FUNCTION X:x RETURN Z IS H G    {: :}
    |   BEGIN I                         {: :}
    ;
H   ::=  C H                            {: :}
    |   BEGIN I G                       {: :}
    ;
I   ::=  L I                            {: :}
    |   M I                             {: :}
    |   E I                             {: :}
    |   P I                             {: :}
    |   E3 I                            {: :}
    |   E4 I                            {: :}
    |   error I
    |   END X PC                        {: :}
    ;

/* Contenedores de terminales id*/
X   ::=  ID:i           {: /* RETURN = i; */ :}
    ;
X2  ::= X COMA X2      {: /**/ :}
    |   X
    ;

/* Contenedores de tipos de datos */
Z   ::=  DATATYPES:dt  {: /* RETURN = d; */ :}
    ;

/* Contenedores de valores */
N   ::=  NUM:n          {: /* RETURN = n; */ :}
    ;
N1  ::=  NUM DOUBD NUM  {:  :}
    ;

/* Declaración de Tipos */
C   ::=  X2 DOS Z:z D   {: :}
    ;
D   ::=  ASSIGN N:n PC  {: :}
    |    PC              {: :}
    ;

/* Condicionales */
L   ::=  IF L1 L2         {:  :}
    ;
L2  ::=  L L2             {:  :}
    |   E L2              {:  :}
    |   M L2              {:  :}
    |   P L2              {:  :}
    |   ELSE L4           {:  :}
    |   ELSIF L1 L4       {:  :}
    |   END IF PC         {:  :}
    ;
L4  ::=  E L4             {:  :}
    |   L L4              {:  :}
    |   M L4              {:  :}
    |   P L4              {:  :}
    |   END IF PC         {:  :}
    ;

/* Asignaciones */
E   ::=  X ASSIGN E2 PC          {:  :}
    ;
E2  ::=  TRUE        {:  :}
    |    FALSE       {:  :}
    |    E5          {:  :}
    ;

/* Ejecucion de Funciones */
E4  ::= X PA                     {:  :}
    ;

/* Parametros */
PA  ::= LP PA2                   {:  :}
    ;
PA2 ::= L3 COMA PA2              {:  :}
    |   L3 RP                    {:  :}
    |   RP                       {:  :}
    ;

/* Operaciones */
E5  ::= E6 OP E6 E7               {:  :}
    |   E6 MOD E6 E7              {:  :}
    |   E6                        {:  :}
    ;
E6  ::= L3                      {:  :}
    |   E4                      {:  :}
    |   LP E5 RP                {:  :}
    ;
E7  ::= OP E6                   {:  :}
    |   MOD E6                  {:  :}
    |                           {:  :}
    ;
/* Retornos */
E3  ::= RETURN E5               {:  :}
    ;

/* Iteraciones */
M   ::=  LOOP M1                {:  :}
    |   FOR N IN N1 LOOP M1     {:  :}
    |   WHILE L6 M1             {:  :}
    ;
M1  ::=  M M1                   {:  :}
    |   E M1                    {:  :}
    |   L M1                    {:  :}
    |   P M1                    {:  :}
    |   END LOOP PC             {:  :}
    ;

/* Comparaciones */
L1  ::=  E5 OPREL E5 AND L1    {: /* result = AND (OPREL(e5,e5), L1)*/ :}
    |  E5 OPREL E5 OR  L1    {:  /*result = OR (OPREL(e5,e5), L1)*/:}
    |  E5 OPREL E5 THEN      {:  /* result = oprel(e5, e5)*/:}
    ;
L3  ::=  N:n              {: /* RETURN = n */ :}
    |   X:x               {: /* RETURN = x */ :}
    ;

/* Grupo de condicionales para mientras */
L6  ::= L1 L6                 {:  :}
    |   AND L1 L6             {:  :}
    |   OR L1 L6              {:  :}
    |   LOOP                  {:  :}
    ;

/* Imprimir o leer valores */
P   ::=  GET LP P1 RP PC    {:  :}
    |   PUT LP P2 RP PC     {:  :}
    ;
P1  ::=  ID                 {:  :}
    ;
P2  ::=  ID                 {:  :}
    |   EXP                 {:  :}
    |   NUM                 {:  :}
    ;
