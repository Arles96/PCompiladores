import java_cup.runtime.*;

/* Codigo para el manejo de errores */
parser code
{:
  // Metodo al se llama automaticamente ante algun error sintactico
  public void syntax_error (Symbol s) {
    String lexema = s.value.toString();
    int fila = s.right;
    int columna = s.left;
    System.out.println("!!! Error sintactico recuperado !!!!");
    System.out.println("Lexema " + lexema);
    System.out.println("Fila " + fila);
    System.out.println("Columna " + columna);
  }

  // Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
  public void unrecover_syntax_error(Symbol s) {
    String lexema = s.value.toString();
    int fila = s.right;
    int columna = s.left;
    System.out.println("!!! Error sintactico recuperado !!!!");
    System.out.println("Lexema " + lexema);
    System.out.println("Fila " + fila);
    System.out.println("Columna " + columna);
  }

:}

/*Palabras reservadas*/
terminal ABORT, ELSE, NEW, RETURN, ABS, ELSIF, NOT;
terminal REVERSE, ABSTRACT, END, NULL, ACCEPT, ENTRY;
terminal SELECT, ACCESS, EXCEPTION, OF, SEPARATE;
terminal ALIASED, EXIT, OR, ALL, OTHERS, SUBPROCEDURE, AND;
terminal FOR, OUT, ARRAY, FUNCTION, AT, TAGGED, GENERIC;
terminal PACKAGEA, TASK, BEGIN, GOTO, PRAGMA, TERMINATE;
terminal BODY, PRIVATE, THEN, IF, PROCEDURE, TYPE, CASE;
terminal IN, PROTECTED, CONSTANT, UNTIL, IS, RAISE;

/* terminal use, with; */
terminal DECLARE, RANGE, DELAY, LIMITED, RECORD, WHEN;
terminal DELTA, LOOP, REM, WHILE, DIGITS, RENAMES;
terminal DO, MOD, REQUEUE, XOR;

/*terminal de comentarios*/
terminal COMMENT;

/*terminales de booleanos*/
terminal TRUE, FALSE;

/* terminal de valores */
terminal NUM;

/* Tipo de datos */
terminal DATATYPES, SUBTYPE;

/* Operadores */
terminal ARROW, DOUBD, DOUBAPS, ASSIGN, NOTEQ;
terminal LLB, RLB, BOX, QM, NS, AM, AP, LP, RP, OP;
terminal COMA, PUNTO, OPREL, DOS, PC;
terminal VERTICAL, LSQB, RSQB, LCB, RCB;

/* String */
terminal EXP;

/* Observacion con el guinb*/
terminal GUINB;

/* Funcion predefinidas */
terminal GET, PUT;

/* id para variables, procedimientos y funciones */
terminal ID;

/* Sección de no terminales */

non terminal A;

/* no terminales de procedimientos y funciones */
non terminal String F, G, H, I;

/* no terminales de terminales de ids*/
non terminal String X, X2;

/*no terminales de tipos de datos*/
non terminal String Z;

/* no terminales de valores */
non terminal String N, N1;

/* no terminales de declaración de tipos */
non terminal String C, D;

/* no terminales de las condicionales */
non terminal String L, L2, L4;

/* no terminales del cuerpo de expresiones */
non terminal String E;

/* no terminales de las operaciones */
non terminal String E2;

/* no terminales de iteraciones */
non terminal String M, M1;

/* no terminales de comparacion */
non terminal String L1, L3;

/* no terminales de grupo de comparaciones para condicionales*/
non terminal String L5;

/* no terminales de grupo de comparaciones para mientras */
non terminal String L6;

/* non terminales de obtener e imprimir valores */
non terminal String P, P1, P2;

start with A;

/* Procedimientos y Funciones */
A   ::=  F                              {: :}
    ;
F   ::=  PROCEDURE X:x IS G             {: :}
    ;
G   ::=  C:c G                          {: :}
    |   FUNCTION X:x RETURN IS H        {: :}
    |   BEGIN I                         {: :}
    ;
H   ::=  C H                            {: :}
    |   BEGIN I                         {: :}
    ;
I   ::=  L I                            {: :}
    |   M I                             {: :}
    |   E I                             {: :}
    |   P I                             {: :}
    | END X PC                          {: :}
    ;

/* Contenedores de terminales id*/
X   ::=  ID:i           {: /* RETURN = i; */ :}
    ;
X2  ::= X COMA X2      {:  :}
    |   X
    ;

/* Contenedores de tipos de datos */
Z   ::=  DATATYPES:dt  {: /* RETURN = d; */ :}
    ;

/* Contenedores de valores */
N   ::=  NUM:n          {: /* RETURN = n; */ :}
    ;
N1  ::=  NUM DOUBD NUM  {:  :}
    ;

/* Declaración de Tipos */
C   ::=  X2 DOS Z:z D   {: :}
    ;
D   ::=  ASSIGN N:n PC  {: :}
    |   PC              {: :}
    ;

/* Condicionales */
L   ::=  IF L5 L2         {:  :}
    ;
L2  ::=  L L2             {:  :}
    |   E L2              {:  :}
    |   M L2              {:  :}
    |   ELSE L4           {:  :}
    |   ELSIF L5 L4       {:  :}
    |   END IF PC         {:  :}
    ;
L4  ::=  E L4             {:  :}
    |   L L4              {:  :}
    |   M L4              {:  :}
    |   END IF PC         {:  :}
    ;

/* Asignaciones */
E   ::=  X ASSIGN E2            {:  :}
    |    X ASSIGN TRUE PC       {:  :}
    |    X ASSIGN FALSE PC      {:  :}
    ;

/* Operaciones */
E2  ::= L3 E2                   {:  :}
    |   OP L3 E2                {:  :}
    |   PC                      {:  :}
    ;

/* Iteraciones */
M   ::=  LOOP M1                {:  :}
    |   FOR N IN N1 LOOP M1     {:  :}
    |   WHILE L6 M1             {:  :}
    ;
M1  ::=  M M1                   {:  :}
    |   E M1                    {:  :}
    |   L M1                    {:  :}
    |   END LOOP PC             {:  :}
    ;

/* Comparaciones */
L1  ::=  L3 OPREL L3      {:  :}
    ;
L3  ::=  N:n              {: /* RETURN = n */ :}
    |   X:x               {: /* RETURN = x */ :}
    ;

/* Grupo de condicionales para condicionales */
L5  ::= L1 L5                 {:  :}
    |   AND L1 L5             {:  :}
    |   OR L1 L5              {:  :}
    |   THEN                  {:  :}
    ;

/* Grupo de condicionales para mientras */
L6  ::= L1 L6                 {:  :}
    |   AND L1 L6             {:  :}
    |   OR L1 L6              {:  :}
    |   LOOP                  {:  :}
    ;

/* Imprimir o leer valores */
P   ::=  GET LP P1 RP PC    {:  :}
    |   PUT LP P2 RP PC     {:  :}
    ;
P1  ::=  ID                 {:  :}
    ;
P2  ::=  ID                 {:  :}
    |   EXP                 {:  :}
    |   NUM                 {:  :}
    ;
